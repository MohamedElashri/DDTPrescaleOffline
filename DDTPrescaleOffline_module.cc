////////////////////////////////////////////////////////////////////////
// Class:       Mono
// Module Type: analyzer
// File:        DDTPrescaleOffline_module.cc
//
// Generated at Thu Mar 14 13:30:55 2019 by Mohamed Elashri using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////
// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
// NOvASoft includes
#include "RawData/RawDigit.h"
#include "RawData/FlatDAQData.h"
#include "RawData/RawTrigger.h"
// ROOT includes
#include <TTree.h>
// DDT includes
#include "DAQDataFormats/TriggerDefines.h"
#include "DAQDataFormats/RawEvent.h"
#include "DAQDataFormats/RawTrigger.h"
#include "DAQDataFormats/RawTriggerMask.h"
#include "DAQDataFormats/RawDataBlock.h"
#include "OnlineMonitoring/producer/RawEventUnpacker.cxx"
 #include "DAQ2RawDigit/OnlineUnpack.h"
// Standard C++ libraries
#include "iostream"
namespace Mono {
  class Mono;
}
class Mono::Mono : public art::EDAnalyzer {
public:
  explicit Mono(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  // Plugins should not be copied or assigned.
  Mono(Mono const &) = delete;
  Mono(Mono &&) = delete;
  Mono & operator = (Mono const &) = delete;
  Mono & operator = (Mono &&) = delete;
  // Required functions.
  void analyze(art::Event const & e) override;
  void endSubRun(art::SubRun const & s) override;
  void beginJob() override;
  void endJob() override;
private:
  unsigned int fRun;                ///< Run number
  unsigned int fSubRun;            ///< Subrun number
  unsigned int fEvent;            ///< Event number
  unsigned int fTrigger;         ///< Trigger type
  unsigned int n_events;        /// number of events
  uint32_t     fprescale;      ///< prescale number
  unsigned int prescale_sum;  /// sum of prescales
  float prescale_mean;       /// average prescale
  std::string  fRawDataLabel; ///< ART module label for Raw Data
  // Declare member data here.
  // This ART Service allows us to interact with TFiles on disk.
  art::ServiceHandle<art::TFileService> tfs;
  TTree* Job;
};
Mono::Mono::Mono(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),  // ,
  fRun(0),
  fSubRun(0),
  fEvent(0),
  fTrigger(0),
  fprescale(0),
  prescale_sum(0),
  n_events(0),
  prescale_mean(0),
  fRawDataLabel(p.get<std::string>("RawDataLabel"))
{}
void Mono::Mono::analyze(art::Event const & e)
{
// use art:event method to get run,subrun and event numbers
  fRun    = e.run();
  fSubRun = e.subRun();
  fEvent  = e.event();
// use rawdata::RawTrigger method to get trigger ID
  art::Handle< std::vector<rawdata::RawTrigger> > trigv;
  e.getByLabel(fRawDataLabel, trigv);
  const rawdata::RawTrigger& trig = (*trigv)[0];
  fTrigger = trig.fTriggerMask_TriggerType;
  // use rawdata::RawTrigger method to get prescale number
  art::Handle< std::vector<rawdata::RawTrigger> > rawtrigger;
  e.getByLabel(fRawDataLabel, rawtrigger);
  const rawdata::RawTrigger& pre = (*rawtrigger)[0];
  fprescale = pre.fTriggerMask_Prescale;
// sum of prescale and get number of events.
prescale_sum += fprescale;
n_events += 1;
// averaging the prescale over events and get prescale average per SubRun
prescale_mean = prescale_sum / n_events;
  // Now to print our values
std::cout << "run = " << fRun << std::endl;
std::cout << "SubRun = " << fSubRun << std::endl;
std::cout << "Event = " << fEvent << std::endl;
std::cout << "TriggerID = " << fTrigger << std::endl;
std::cout << "Prescale = " << fprescale << std::endl;
}
void Mono::Mono::endSubRun(art::SubRun const & s)
{
// We want to get these numbers per SubRun so we print them in endSubRun level.
std::cout << "prescale total = " << prescale_sum << std::endl;
std::cout << "n_events = " << n_events << std::endl;
std::cout << "average prescale = " << prescale_mean << std::endl;
}
 void Mono::Mono::beginJob()
{
  Job = tfs->make<TTree>("Trigger", "Trigger");
  Job->Branch("Run",    &fRun);
  Job->Branch("SubRun", &fSubRun);
  Job->Branch("Event",  &fEvent);
  Job->Branch("TriggerID",    &fTrigger);
  Job->Branch("Prescale",    &fprescale);
  Job->Branch("number of events",    &n_events);
}
void Mono::Mono::endJob()
 {
  // Implementation of optional member function here.
}
DEFINE_ART_MODULE(Mono::Mono)
